% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}


\title{Fashion Quest Documentation}
\date{February 05, 2011}
\release{1.0 Alpha 2}
\author{Mike Cantelon}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\def\PYG@tok@gd{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\def\PYG@tok@gu{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\def\PYG@tok@gt{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.25,0.82}{##1}}}
\def\PYG@tok@gs{\let\PYG@bf=\textbf}
\def\PYG@tok@gr{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\def\PYG@tok@cm{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@vg{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@m{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mh{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@cs{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\colorbox[rgb]{1.00,0.94,0.94}{##1}}}
\def\PYG@tok@ge{\let\PYG@it=\textit}
\def\PYG@tok@vc{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@il{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@go{\def\PYG@tc##1{\textcolor[rgb]{0.19,0.19,0.19}{##1}}}
\def\PYG@tok@cp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@gi{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\def\PYG@tok@gh{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\def\PYG@tok@ni{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\def\PYG@tok@nl{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\def\PYG@tok@nn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@no{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\def\PYG@tok@na{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@nb{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\def\PYG@tok@nd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\def\PYG@tok@ne{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@nf{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\def\PYG@tok@si{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\def\PYG@tok@s2{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@vi{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@nt{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\def\PYG@tok@nv{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\def\PYG@tok@s1{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@gp{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@sh{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@ow{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@sx{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\def\PYG@tok@bp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c1{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@kc{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@c{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\def\PYG@tok@mf{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@err{\def\PYG@bc##1{\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{##1}}}
\def\PYG@tok@kd{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@ss{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\def\PYG@tok@sr{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\def\PYG@tok@mo{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@mi{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\def\PYG@tok@kn{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@o{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\def\PYG@tok@kr{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@s{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@kp{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@w{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\def\PYG@tok@kt{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\def\PYG@tok@sc{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sb{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@k{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\def\PYG@tok@se{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\def\PYG@tok@sd{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Introduction}
\label{introduction:introduction}\label{introduction::doc}\label{introduction:fashion-quest}
Fashion Quest is an interactive fiction framework created to make \href{http://en.wikipedia.org/wiki/Interactive\_fiction}{text adventure games} about fashion because we love fashion and we love text adventure games. Fashion Quest is written in the Ruby programming language and requires \href{http://shoes.heroku.com/}{Shoes}, a cross-platform GUI framework created by \href{http://en.wikipedia.org/wiki/Why\_the\_lucky\_stiff/}{Why the Lucky Stiff}. Fashion Quest has been tested with Shoes 2.

Games are created in Fashion Quest by defining game elements using YAML and bits of Ruby. The framework includes three demonstration games. The game ``Fashion Quest: Daydream'' is very small and designed to demonstrate non-player character features. It lives in the \emph{daydream} directory. The game ``Pirate Adventure Knockoff'' is a port of the 1978 text adventure \href{http://en.wikipedia.org/wiki/Pirate\_Adventure}{``Pirate Adventure''} by Scott and Alexis Adams and lives in the \emph{pirate\_adventure} directory. The game \href{http://www.firthworks.com/roger/cloak/}{``Cloak of Darkness''} is a port of a game that was created as a means of comparing different interaction fiction frameworks. It lives in the \emph{cloak\_of\_darkness} directory. There is also a game skeleton exists primarily to serve as the basis of new games. It lives in the \emph{new\_game} directory.

To play either of these use Shoes to run \emph{run.rb} and select which youâ€™d like to play.

Thanks to Why the Lucky Stiff for creating Shoes and inspiring the creative use of computers!


\section{Why Use a Framework?}
\label{introduction:why-use-a-framework}\label{introduction:cloak-of-darkness}
Development of interactive fiction (IF) involves dealing with problems not inherent in many other realms of development, including parsing and game world simulation. Because of this a number of frameworks have been developed to deal with the IF domain.

Fashion Quest is a relative newcomer. Established frameworks include \emph{Inform}, \emph{Adrift}, and \emph{TADS}.

\href{http://www.adrift.org.uk/}{ADRIFT} is one of the most user friendly of the frameworks. It allows games to be created using a GUI. It is not, however, extensible, cross-platform, or open source.

\href{http://www.inform-fiction.org/I7/Welcome.html}{Inform} is one of the most elegant and established of the frameworks. It allows games to be developed either in natural language (Inform 7) or a specialize programming language (Inform 6). It is extensible, cross-platform, open source, and supports automated game testing.

\href{http://www.tads.org/}{TADS} is reputedly more powerful than Inform, but has a fairly steep learning curve.

The \href{http://www.firthworks.com/roger/cloak/index.html}{Cloak of Darkness} site is useful for comparing interaction fiction frameworks as it contains implementations of the same simple interactive fiction game created using twenty different IF frameworks.


\section{Design Goals of Fashion Quest}
\label{introduction:design-goals-of-fashion-quest}\label{introduction:id1}
Fashion Quest was created with the goal of being somewhere between ADRIFT and Inform in ease of use.

The design goals are as follows:
\begin{itemize}
\item {} 
\textbf{Minimalist}

Fashion Quest was designed to be lightweight and easy to learn. The simulated world is as simple as possible. Game command syntax is defined using patterns rather than natural language rules.

\item {} 
\textbf{Cross-platform}

By leveraging Shoes, Fashion Quest is able to provide a consistant user experience across whether being used in Windows, Mac OS, or Linux.

\item {} 
\textbf{Programmer-Friendly}

Fashion Quest development is done using the Ruby programming language rather than a domain-specific programming language. This lessens the framework learning curve as there are many resources for those wishing to learn Ruby (and those who already know Ruby get a head start).

\item {} 
\textbf{Extensible}

Because Fashion Quest is open source, it is fully extensible. Default game engine behaviour can be overriden using monkey patching.

\end{itemize}


\chapter{Overview}
\label{overview:overview}\label{overview::doc}

\section{Game Elements}
\label{overview:game-elements}
The elements that make up a game include the player, locations, props, non-player characters, doors, game state, commands, and transitions. All are defined using YAML with embedded Ruby.

Elements that the player may be able to carry are called \emph{game components}. These include props, characters, and doors. Usually only props can be carried, but some games might require a character (a parrot, for example) or door (a teleportation device, for example) be carryable.

Game state allows ad-hoc game world conditions to be stored. In the demonstration game ``Pirate Adventure Knockoff'', for example, game state is used to record whether or not the tide is in.

Commands and transitions rely on Ruby logic to manipulate the other game elements. Commands are triggered by the user whereas transitions are triggered by the conditions of other game elements.


\section{Framework Directory Structure}
\label{overview:framework-directory-structure}
The \emph{framework directory} is the directory containing \emph{run.rb}. Its file structure is explained below. The \emph{new\_game} directory contains a skeleton you can use as the basis of a new game.

\begin{threeparttable}
\capstart\caption{Framework directory file structure}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

\textbf{Directory/File}
 & 
\textbf{Description}
\\

doc
 & 
Directory containing developer documentation
\\

engine
 & 
Directory containing framework engine logic
\\

games
 & 
Directory containing games
\\

standard\_commands
 & 
Directory containing standard game command definitions that can be shared between games
\\
\hline
\end{tabulary}

\end{threeparttable}


Files used to define games are put in \emph{game directories}. These directories can be put inside the \emph{framework directory}. Every \emph{game directory} must contain a \emph{config.yaml} file (in which basic game configuration is stored). When Fashion quest starts, it will look through all directories in the \emph{framework directory} to see which ones contain a \emph{config.yaml} file. If only one game directory is found, Fashion Quest will automatically start this game. Otherwise, a game selector will be presented to the user.


\section{Game Directory Structure}
\label{overview:game-directory-structure}
The \emph{game directory} file structure is explained below.

\begin{threeparttable}
\capstart\caption{Game directory file structure}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

\textbf{Directory/File}
 & 
\textbf{Description}
\\

config.yaml
 & 
File containing YAML basic game configuration
\\

transitions.yaml
 & 
File containing YAML transition definitions
\\

characters
 & 
Directory containing YAML character definition files
\\

commands
 & 
Directory containing YAML command definition files
\\

doors
 & 
Directory containing the YAML door definitions file
\\

locations
 & 
Directory containing YAML location definition files
\\

parsing
 & 
Directory containing parsing-related YAML configuration files
\\

player
 & 
Directory containing the YAML player definition file
\\

props
 & 
Directory containing the YAML props definition file
\\
\hline
\end{tabulary}

\end{threeparttable}



\section{Built-in Commands}
\label{overview:built-in-commands}
There are a number of built-in game commands that don't appear in the \emph{standard\_commands} directory. These are: \emph{restart}, \emph{clear}, \emph{load}, \emph{save}, \emph{load walkthrough}, \emph{save walkthrough}, save \emph{transcript}, and \emph{compare to transcript}.

\emph{restart} restarts the game. \emph{clear} clears the command output. \emph{load} and \emph{save} allow the user to load or save their game progress to a file.

The other built-in commands are developer-oriented and discussed in the testing section.


\chapter{Game World Elements}
\label{elements:game-world-elements}\label{elements::doc}
Each game component must have a globally unique identifier. There are two ways to define game components: either using \href{http://www.yaml.org/}{YAML}, a human-readable standard used to describe data structures using text, or using Ruby. This documentation focuses on the use of YAML, but if you're interested in using Ruby check out the \emph{Cloak of Darkness} implementation for an example.


\section{Locations}
\label{elements:yaml}\label{elements:locations}
Locations are places a player can visit during a game.

Each location is defined in its own YAML file within the `locations' subdirectory of the game directory.

The example below defines a location with a number of exits. The unique indentifier of the location is \emph{entrance}. Each exit has a destination, which is the unique identifier of the location to which it leads. Note that the \emph{stairs} exit has a description: ``upstairs''. This is used to describe travelling this way. For example a character taking this exit will be described using  ``the hobo goes upstairs'' rather than ``the hobo goes stairs''.

\begin{Verbatim}[commandchars=@\[\]]
entrance:
  exits: 
    north:
      destination: yard
    south:
      destination: hallway
    up:
      destination: upstairs
    stairs:
      destination: upstairs
      description: upstairs

  description: @textbar[]
    You are in the sunlit entranceway of a sizeable home.

    To the north is a door leading outside. Stairs lead upwards. A hallway leads south.
\end{Verbatim}


\section{Doors}
\label{elements:doors}
Doors allow two or more locations to be connected. If a door connects more than two locations, when entering from one location you will end up at a random pick of the other locations.

Doors are defined in a file called \emph{doors.yaml} within the \emph{doors} subdirectory of the game directory.

The example below defines a door that allows the player to travel between two locations. The door is locked by default, but may be opened using the \emph{brass key} prop. The unique indentifier of the door is \emph{door}.

\begin{Verbatim}[commandchars=@\[\]]
door:
  description: The door is made of dark-brown wood.
  locations:
  - hallway
  - bedroom
  traits:
    opened: false
    open@_with:
    - brass key
\end{Verbatim}


\section{Props}
\label{elements:props}
Props are items that players can interact with in the game. They may be portable items, such as a pack of cigarettes, or items that can't be carried, such as a dresser.

Props are defined in a file called \emph{props.yaml} within the \emph{props} subdirectory of the game directory.

The example below defines a dresser located in a location with the unique identifier \emph{bedroom}. The dresser can be opened by the player and contains another prop, a pack of \emph{smokes}.

\begin{Verbatim}[commandchars=@\[\]]
dresser:
  description: The dresser looks like it has seen better days.
  location: bedroom
  traits:
    opened: false
    portable: false
    contains:
      - smokes
\end{Verbatim}

Props, as the example below shows, can have one or more aliases. The aliases can be used by players to refer to the prop.

\begin{Verbatim}[commandchars=@\[\]]
safety sneakers:
  aliases:
  - sneakers
\end{Verbatim}

Props can have traits set that determine what can be done with them.


\subsection{Portability}
\label{elements:portability}
If a prop has its \emph{portable} trait set to true, the player will be able to take it. When props are defined using \emph{props.yaml} the \emph{portable} trait gets automatically set to true if not otherwise specified.


\subsection{Visibility}
\label{elements:visibility}
If props have their \emph{visible} trait set to true, these props will be automatically shown when the player looks. When props are defined using \emph{props.yaml} the \emph{visible} trait gets automatically set to true if not otherwise specified.


\subsection{Text}
\label{elements:text}
If a prop has its \emph{text} trait set, the prop can be read. \emph{text} may be set to text to be shown to the player or, if the first character is ``\textgreater{}'', a text file in the game folder.

\begin{Verbatim}[commandchars=@\[\]]
leaflet:
  description: The leaflet is faded yellow and seems to warn against something.
  traits:
    text: "The leafet is about men's rights. It thinks the child support is wrong.\n"
\end{Verbatim}


\subsection{Containers}
\label{elements:containers}
If a prop has the \emph{open} trait set to false it can contain other props. These props are specified using the \emph{contains} trait. The props may require other props to open them, if the \emph{open\_with} trait is set.

\begin{Verbatim}[commandchars=@\[\]]
box:
  description: The box is made of wood.
  location: field
  traits:
    opened: false
    open@_with: hammer
    contains:
      - stamps
\end{Verbatim}


\subsection{Size}
\label{elements:size}
The \emph{size} trait can be used to prevent large props from passing through doors that have lesser \emph{size} traits defined.

The ``crack'' door in the Pirate Adventure demo game, for example, has a size of 1.

\begin{Verbatim}[commandchars=@\[\]]
---
crack:
  name: crack
  description: The crack is too narrow to bring large items through.
  locations:
  - top@_of@_hill
  - cavern
  traits:
    size: 1
    opened: true
\end{Verbatim}

The size of the crack prevents the player from entering it if carrying props, such as the book and the shovel, that have a size of 2.


\subsection{Construction}
\label{elements:construction}
A prop can be specified as being built from other props. This is done by setting the \emph{build\_with} trait to the component props. If any of the component props should be taken out of play, they should be includes in the \emph{build\_consumes} trait.

\begin{Verbatim}[commandchars=@\[\]]
table:
  traits:
    build@_with:
    - lumber
    - nails
    - saw
    - hammer
    build@_consumes:
    - lumber
    - nails
\end{Verbatim}


\subsection{Get With}
\label{elements:get-with}
If you need to have one or more props to get another (a bottle, for example, to get water), you can set the \emph{get\_with} trait of a prop.

\begin{Verbatim}[commandchars=@\[\]]
water:
  plural: true
  location: ocean
  traits:
    get@_with:
    - bottle
  events:
    on@_get: @textbar[]
      "The bottle holds the water.\n"
    on@_drop: @textbar[]
      "The bottle is now empty.\n"
\end{Verbatim}


\subsection{Buried Props}
\label{elements:buried-props}
If a prop has its \emph{can\_dig} trait set to true it can be used to dig. If a prop has its \emph{buried} trait set to true it can be dug up. When a prop is dug up its \emph{portable} and \emph{visible} traits get set to true. Below is an example of a buried prop.

\begin{Verbatim}[commandchars=@\[\]]
treasure:
  description: This treasure is really something else. It might be worth something, even!
  location: yard
  traits:
    visible: false
    buried: true
    portable: false
\end{Verbatim}


\subsection{Wearables}
\label{elements:wearables}
If a prop can be worn by the player, set the \emph{wearable} trait to true.

\begin{Verbatim}[commandchars=@\[\]]
shirt:
  description: "The t-shirt evokes the desire to party."
  traits:
    wearable: true
\end{Verbatim}


\subsection{Flammables}
\label{elements:flammables}
Locations can be set to be dark, in which case a player needs a source of illumination to see the description. If a prop has the trait \emph{lit} set to false the player will be able to light on fire using a prop that has the \emph{firestarter} trait set to true. If the prop has its \emph{burn\_turns} trait set to a number then it will only burn for that number of turns.

\begin{Verbatim}[commandchars=@\[\]]
torch:
  location: attic
  traits:
    lit: false
    burn@_turns: 150
\end{Verbatim}


\subsection{Support}
\label{elements:support}
If a prop has the \emph{supports} trait set to true, other props can be put on it. If the prop has the \emph{supports\_only} trait set to one or more props, only these props will be supported by it.

\begin{Verbatim}[commandchars=@\[\]]
hook:
  description: "A hook on which to hang a garment."
  traits:
    visible: false
    portable: false
    supports: true
\end{Verbatim}


\section{Characters}
\label{elements:characters}
Characters are beings that players can interact with in the game.

Each character is defined in its own YAML file within the `characters' subdirectory of the game directory.

The example below defines a character located in a location with the unique identifier \emph{shack}. The pirate will accept the \emph{rum} prop if the player gives it to him.

\begin{Verbatim}[commandchars=@\[\]]
---
pirate:
  description: The pirate has a wicked look.
  location: shack
\end{Verbatim}


\subsection{Mobility}
\label{elements:mobility}
Characters will wander from location to location if their \emph{mobility} is set. Mobility is the probability (in percentage) that the character will move each turn. The character example below will go to a new location each turn.

\begin{Verbatim}[commandchars=@\[\]]
---
cat:
  location: bedroom
  mobility: 100
\end{Verbatim}


\subsection{Aggression}
\label{elements:aggression}
Characters will be prone to attack the player if their \emph{aggression} is set. Aggression is the probability (in percentage) that the character will start to attack each turn. A character's \emph{strength} determines how much damage it can do each attack if they don't posess a weapon prop (the \emph{default\_attack} property determines how the weaponless attack will be described). If a character does have a weapon prop with a greater attack strength than their default, the character will automatically use it in attacks.

The character example below has a 5\% chance of turning hostile and will do one or two hit points of damage each turn.

\begin{Verbatim}[commandchars=@\[\]]
--
cat:
  location: bedroom
  mobility: 100
  description: The cat is small and agile.
  hp: 2
  strength: 1
  aggression: 5
\end{Verbatim}

A prop can serve as a weapon if the prop's \emph{attack strength} is set. If a character possesses a weapon, this weapon will be used if its \emph{attack strength} is greater than the character's \emph{strength}. The prop example below is possessed by the ``deadbeat'' character and gives the character a strength of 7.

\begin{Verbatim}[commandchars=@\[\]]
shiv:
  attack strength: 7
  description: The shiv looks sharp... useful.
  location: deadbeat
\end{Verbatim}


\subsection{Communication}
\label{elements:communication}
Characters can be asked questions about topics. Topics and responses are put into the \emph{discusses} setting. The example below shows a character that, when asked about a ``party'', ``parties'', or ``partying'', responds with one of two opinions about the topic.

\begin{Verbatim}[commandchars=@\[\]]
---
rick:
  discusses:
    ?
      - party
      - parties
      - partying
    :
      - @textgreater[]Parties are a real gas.
      - @textgreater[]I'd like to think that I'm in it for the party.
\end{Verbatim}

If the letter ``\textgreater{}'' is the first character of a response, double quotes will be put around the remaining characters of the response before outputting to the player.

Characters can also be made to occasionally mutter random things or be described as doing random things. The example below shows a character that has a 10\% chance, each turn, of either being described as looking at the player or as saying something.

\begin{Verbatim}[commandchars=@\[\]]
child:
  location: hallway
  description: "The child look sad. The child has no shoes."
  mutter@_probability: 10
  mutters:
  - The child looks at you sadly.
  - @textgreater[]Why is the world against me?
\end{Verbatim}


\subsection{Trade}
\label{elements:trade}
Characters may be willing to accept props as gifts or for trade.

In the example below the character will accept the gift of rum.

\begin{Verbatim}[commandchars=@\[\]]
---
pirate:
  description: The pirate has a wicked look.
  location: shack
  exchanges:
    rum: true
\end{Verbatim}

In the example below the character will give a pair of shoes and a shiv in exchange for smokes.

\begin{Verbatim}[commandchars=@\[\]]
---
deadbeat:
  exchanges:
    smokes:
    - shoes
    - shiv
\end{Verbatim}


\subsection{Portability}
\label{elements:id1}
Characters can be set to allow the player to carry them, as with the example below.

\begin{Verbatim}[commandchars=@\[\]]
---
parrot:
  description: The parrot looks great.
  location: shack
  traits:
    portable: true
\end{Verbatim}


\subsection{Logic}
\label{elements:logic}
Characters can execute custom Ruby logic each turn. In the example below the parrot character will, if in the same location as the player, occassionally eat a cracker if the player possesses crackers.

\begin{Verbatim}[commandchars=@\[\]]
---
parrot:
  logic: @textbar[]
    output = ''

    @# Parrot interaction
    if @PYGZat[]location == @PYGZat[]player.location

      @# The parrot occasionally eats a cracker if player has them
      case rand(3) + 1
        when 1:
          if @PYGZat[]props@PYGZlb[]'crackers'@PYGZrb[].location == 'player'
            output @textless[]@textless[] "The parrot ate a cracker.\n"
          end
      end
    end
\end{Verbatim}


\section{State}
\label{elements:state}
Game state is used to keep track of game conditions other than the state of other game elements. State can be referenced, or set, from logic within commands, transitions, and events.

One example, from the \emph{Pirate Adventure Knockoff} demonstration game, is tide state. Tide state is changed using transitions that set state using simple logic, such as the line shown below.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n+nv+vi}{@state}\PYG{o}{[}\PYG{l+s+s1}{'tide'}\PYG{o}{]} \PYG{o}{=} \PYG{l+s+s1}{'in'}
\end{Verbatim}


\chapter{Game World Manipulation}
\label{manipulation:game-world-manipulation}\label{manipulation::doc}
Once game elements are defined, they can be manipulated in the game by commands, events, and transitions.


\section{Commands}
\label{manipulation:commands}
Each command is defined in its own YAML file within the `commands' subdirectory of the game directory. If a command file within this directory exists, but is empty, the game engine will look for a command with the same filename in the \emph{standard\_commands} directory.

\begin{notice}{note}{Note:}
Symbolic links can also be used, instead of empty command files, to point to standard commands but Windows doesn't support symbolic links so the game won't be cross platform.
\end{notice}

The example below, from the ``Pirate Adventure Knockoff'' demonstration game, defines a command that enables the player to wake up the pirate character. If the character's \emph{asleep} trait is \emph{true} the \emph{asleep} trait will be changed to \emph{false} if the player enters the command \emph{wake pirate}.

Commands are made up of syntax and logic.

TIP: Keep the idea of reusing commands between games in mind when creating commands. If logic is game-specific, try to use transitions instead of commands to implement the logic.


\subsection{Syntax Forms}
\label{manipulation:syntax-forms}
Command syntax can have multiple forms. For example, a command that allows the player to pick up a prop could have the form \emph{get \textless{}prop\textgreater{}} or \emph{take \textless{}prop\textgreater{}}.

Each syntax form is composed of keywords and parameters. Parameters are usually references to game elements. With the case of the above example \emph{get} and \emph{take} are the keywords and \emph{\textless{}prop\textgreater{}} is the reference parameter.

Keywords are static words identifying an action: verbs. References refer to ``things'': nouns.

Four types of parameters can be used: prop references, character references, door references, and text.

Prop, character, and door references can refer to any prop, character, or door in the same location as the player. If a prop, character, or door is referenced, but doesn't have the same location as the player, an error will be output.

When defining syntax forms, parameters are enclosed in less-than and greater-than symbols. A reference paramter can be given the same name as its type or can be given a name. A syntax form containing the prop reference parameter \emph{\textless{}prop\textgreater{}} would pass to the command a reference named \emph{prop}. A syntax form \emph{\textless{}prop:thing\textgreater{}} would pass to the command a reference named \emph{arg{[}'thing'{]}}.

Text parameters are always named. A syntax form containing the ad-hoc reference \emph{\textless{}colour\textgreater{}} would pass to the command the variable \emph{arg{[}'color'{]}}.

Examples:
- ``\textless{}prop\textgreater{}'' for unnamed prop reference
- ``\textless{}character\textgreater{}'' for unnamed prop reference
- ``\textless{}prop:some name\textgreater{}'' for a named prop reference
- ``\textless{}character:some other name\textgreater{}'' for a named character reference
- ``\textless{}anything\textgreater{}'' for an ad-hoc reference


\subsection{Logic}
\label{manipulation:logic}
Command logic is written in Ruby. References to props, characters, or doors can be passed in as specified by syntax forms.

In addition to data passed in via syntax forms, game elements can also be arbitrarily accessed.

\emph{@game} provides access to game properties and methods.

\emph{@player} provides access to player properties and methods.

\emph{@props} provides access to the properties and methods of individual props.

\emph{@characters} provides access to the properties and methods of individual characters.

The best way to understand how commands work is to check out the commands in the \emph{standard\_commands} directory.


\subsection{Noun Grammar Contexts}
\label{manipulation:noun-grammar-contexts}
Characters, doors, and props can be referred to, when outputting messages to the user from commands, using noun grammar context functions. Checking out how noun grammar context functions are used in the standard commands may help you understand them.

Noun grammar context functions work with three basic noun types: singular (``hammer'', ``cat'', etc.), plural (``bottles'', ``bullets''), and proper nouns (``Rick''). Proper nouns will always be capitalized.

The four noun grammar context functions are explained below.


\subsubsection{noun}
\label{manipulation:noun}
\emph{noun} is the most used noun context. It prefixes with ``the '' for non-proper nouns. If a noun is proper, it is capitalized. If a specific \emph{name} setting has been assigned to the object this will be used, otherwise the object's unique ID will be used as a name.

Example: ``You take \#\{prop.noun\}.''


\subsubsection{noun\_cap}
\label{manipulation:noun-cap}
\emph{noun\_cap} is generally used at the start of sentences. It works like \emph{noun}, but capitalizes the first letter.

Example: ``\#\{prop.noun\_cap\} contains something.''


\subsubsection{noun\_direct}
\label{manipulation:noun-direct}
\emph{noun\_direct} works like \emph{noun}, but prefixes with ``a '' (for singlular) or ``some '' for (plural) for non-proper nouns.

Example: ``You find \#\{prop.noun\_direct\}.''


\subsubsection{noun\_direct\_cap}
\label{manipulation:noun-direct-cap}
\emph{noun\_direct\_cap} is gnerally used at the start of sentences. It works like \emph{noun\_direct}, but capitalizes the first letter.

Example: ``\#\{prop.noun\_direct\_cap\} falls from the sky.''


\subsection{Conditions}
\label{manipulation:conditions}
Command conditions are logic that determines if a command can be carried out by the player. Conditions can be defined for individudal commands and/or globally for any command.

Condition logic should return a hash with a ``success'' element (boolean to indicate whether or not the attempted command should be carried out) and, optionally, a ``message'' element that returns information to the player.

Command conditions for individual commands may be defined in a command's YAML file, as shown below.

\begin{Verbatim}[commandchars=@\[\]]
condition: @textbar[]
  if @PYGZat[]props@PYGZlb[]'crackers'@PYGZrb[].location == 'player'
    {'success' =@textgreater[] true, 'message' =@textgreater[] "Crackers give me power.\n"}
  else
    {'success' =@textgreater[] false, 'message' =@textgreater[] "I NEED CRACKERS.\n"}
  end
\end{Verbatim}

A global command condition can be specified in the \emph{command\_condition} element of a game's config.yaml file.


\section{Events}
\label{manipulation:events}
Events enable Ruby logic to be triggered by happenings in the game world. Characters, props, and doors can all have event outcome associated with them.

For example, the \emph{cat} character in the ``Fashion Quest: Daydream'' demonstration game responds to three events: \emph{on\_attack} (when the cat is attacked), \emph{on\_death} (when the cat is killed), and \emph{on\_pet} (when the player pets the cat).

Commands can be used to trigger events. For example, the standard get command triggers the \emph{on\_get} event on a prop (and collects event output into the variable \emph{on\_get\_output} by including the following line:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{on\PYGZus{}get\PYGZus{}output} \PYG{o}{=} \PYG{n+nv+vi}{@game}\PYG{o}{.}\PYG{n}{event}\PYG{p}{(}\PYG{n}{prop}\PYG{p}{,} \PYG{l+s+s1}{'on\PYGZus{}get'}\PYG{p}{)}
\end{Verbatim}

The ``Pirate Adventure Knockoff'' demonstration game uses the \emph{on\_get} event of the \emph{book} prop to change the description of a room, revealing a secret passage, and return a hint to the player that something has changed.

\begin{Verbatim}[commandchars=@\[\]]
book:
  description: The book is large and blood-soaked.
  location: alcove
  events:
    on@_get: @textbar[]
      if not (@PYGZat[]locations@PYGZlb[]'alcove'@PYGZrb[].has@_exit('passage'))
        @PYGZat[]props@PYGZlb[]'book'@PYGZrb[].traits@PYGZlb[]'visible'@PYGZrb[] = true
        @PYGZat[]locations@PYGZlb[]'alcove'@PYGZrb[].add@_to@_description("You see a secret passage.\n")
        @PYGZat[]locations@PYGZlb[]'alcove'@PYGZrb[].set@_exit('passage', 'passageway')
        "There's a strange sound.\n";
      end
\end{Verbatim}

If event YAML is set to be a list of event outcomes then an outcome will be randomly selected from the list when the event is triggered, as an example shows below.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{on\PYGZus{}discuss}\PYG{p}{:}
\PYG{o}{-} \PYG{l+s+s2}{"}\PYG{l+s+s2}{The deadbeat squints at you and shuffles his feet before answering.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{"}
\PYG{o}{-} \PYG{l+s+s2}{"}\PYG{l+s+s2}{The deadbeat tilts his head sceptically before answering.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{"}
\end{Verbatim}


\section{Transitions}
\label{manipulation:transitions}
Transitions enable Ruby logic to be triggered by happenings in the game world. Transitions are more versitile than events: any game condition(s) can be used to trigger the manipulation of any game element(s).

To add transitions to a game, create the file \emph{transitions.yaml} in the appropriate game directory. Transitions are made up of one or more triggering conditions and one or more outcomes.

The example transition below, containing conditions and outcomes extracted from the ``Pirate Adventure Knockoff'' demonstration game, shows a transition that makes a pet leave if neither his master nor food are present.

\begin{Verbatim}[commandchars=@\[\]]
---
conditions:

  ?
    - @PYGZat[]player.location == @PYGZat[]characters@PYGZlb[]'parrot'@PYGZrb[].location
        @&@& @PYGZat[]characters@PYGZlb[]'parrot'@PYGZrb[].location != @PYGZat[]characters@PYGZlb[]'pirate'@PYGZrb[].location
        @&@& @PYGZat[]characters@PYGZlb[]'parrot'@PYGZrb[].location != @PYGZat[]props@PYGZlb[]'crackers'@PYGZrb[].location
  :
    - parrot@_flies@_off

outcomes:

  parrot@_flies@_off: @textbar[]
    if @PYGZat[]props@PYGZlb[]'crackers'@PYGZrb[].location != 'player'
      @PYGZat[]characters@PYGZlb[]'parrot'@PYGZrb[].location = @PYGZat[]props@PYGZlb[]'crackers'@PYGZrb[].location
      "The parrot flies off looking very unhappy...\n"
    end
\end{Verbatim}

If you want a transition output to not return output, end it with a line containing only \emph{``''}.


\chapter{Fine-Tuning}
\label{fine_tuning::doc}\label{fine_tuning:fine-tuning}
Each game's \emph{config.yaml} file allows fine-tuning of a number of elements.

\begin{threeparttable}
\capstart\caption{Game settings}

\begin{tabulary}{\linewidth}{|L|L|}
\hline

\textbf{Setting}
 & 
\textbf{Description}
\\

title
 & 
title of the game (displayed in the window bar)
\\

width
 & 
width of game window
\\

image\_height
 & 
maximum height of images
\\

resizable
 & 
whether or not the player should be able to resize the game window
\\

startup\_message
 & 
text to display to the player upon startup
\\

background
 & 
Background image for game
\\

command\_condition
 & 
Ruby logic that determines whether any command should execute
\\

setup\_logic
 & 
Ruby logic to set up game (see demo games for examples)
\\
\hline
\end{tabulary}

\end{threeparttable}


Other elements that can be set in \emph{config.yaml} are explained later in this section.


\section{Scoring}
\label{fine_tuning:scoring}
If a game incorporates scoring, player actions can result in score increases that generally serve as a marker of game progress. The standard command \emph{score} will let the player know of his or her current score.

Scoring items are configured in \emph{config.yaml}. An example is shown below.

\begin{Verbatim}[commandchars=@\[\]]
scoring:
  cloak@_on@_hook:
    points: 1

  message@_read:
    points: 1
\end{Verbatim}

Each scoring item has a name and point value. Scoring is triggered using Ruby logic. The Ruby logic \emph{@game.set\_score(`\textless{}name of scoring item\textgreater{}')} will trigger a scoring item.


\section{Parsing}
\label{fine_tuning:parsing}
Fashion Quest includes employs a crude, case-insensitive, parsing mechanism that converts player input into ``lexemes'': text elements (single words or game element identifiers such as ``hat'' or ``blue hat'') that can be compared to command syntax forms.

Here's the basic flow of parsing:
\begin{enumerate}
\item {} 
Abbreviated commands are expanded

\item {} 
Input is broken into lexemes (single words or game element indentiers)

\item {} 
Lexemes that match synonyms are replaced

\item {} 
Lexemes that match garbage words are deleted

\item {} 
Lexemes that are aliases to game element IDs are resolved

\end{enumerate}


\subsection{Abbreviated Commands}
\label{fine_tuning:abbreviated-commands}
Abbreviated commands reduce the amount of typing the user must do. One popular convention in interactive fiction is allowing a user simply to enter the first letter of the direction (s)he'd like to go in: \emph{n} for \emph{go north}, for example.

The \emph{command\_abbreviations.yaml} file, in the \emph{parsing} subdirectory of each game's directory, allows a list of abbreviations for specific command instances to be defined using YAML. An example is shown below.

Command abbreviations can alternatively be specified in \emph{config.yaml}. An example is shown below.

\begin{Verbatim}[commandchars=@\[\]]
command@_abbreviations:
  n: "go north"
  s: "go south"
  e: "go east"
  w: "go west"
  u: "go up"
  d: "go down"
\end{Verbatim}

\begin{notice}{note}{Note:}
The \emph{command\_abbreviations.yaml} file isn't the only place command abbreviation can be specified. Command syntax forms that don't contain parameters, like those of the \emph{inventory} command, allow abbreviations to be stored in the command's syntax forms (\emph{i} for inventory, for example).
\end{notice}


\subsection{Synonyms}
\label{fine_tuning:synonyms}
Synonyms help reduce the number of command syntax forms needed to support command syntax variations. The \emph{global\_synonyms.yaml} file, in the game \emph{parsing} subdirectory of each game's directory, can contain a list of word substitutions defined using YAML. These substitutions get applied to a user's command input.

For example, the word ``using'' can be replaced with the word ``with''. This synonym would make the command syntax form ``attack \textless{}character\textgreater{} with \textless{}prop\textgreater{}'' work when the player enters the command ``attack bear using hat''.

Example YAML is shown below.

Synonyms can alternatively be specified in \emph{config.yaml}. An example is shown below.

\begin{Verbatim}[commandchars=@\[\]]
global@_synonyms:
  using: "with"
  examine: "look"
\end{Verbatim}


\subsection{Garbage Words}
\label{fine_tuning:garbage-words}
Garbage words are words with little or no semantic meaning (like ``the'' and ``a). By removing them from the user's command input we recude the number of command syntax forms needed to support command syntax variations. The \emph{garbage\_words.yaml} file, found in the \emph{parsing} subdirectory of each game's directory, can contain a list of words that should be discarded from player input.

Example YAML is shown below.

Garbage words can alternatively be specified in \emph{config.yaml}. An example is shown below.

\begin{Verbatim}[commandchars=@\[\]]
garbage@_words:
- "the"
- "that"
- "this"
- "at"
\end{Verbatim}


\section{Testing}
\label{fine_tuning:testing}
Testing interactive fiction games can be tedious. To make testing easier Fashion Quest provides a couple of simple tools: walkthrough and transcripts (explained in detail later on).

In addition to these tools, the Shoes \emph{alert} function is handy for confirming logic is being executed. \emph{alert(``Hello'')} will, for example, pop up a dialog box with the word ``Hello''. The Shoes \emph{error} function is also handy. \emph{error(``Hello'')} will write the world ``Hello'' to the console.

When there are syntax errors in game logic, or other errors that stop game execution, you can often get useful clues by pressing Alt-/ to view the Shoes debugging console.


\subsection{Walkthroughs}
\label{fine_tuning:walkthroughs}
When a player loads or saves a game, via the built-in \emph{load} and \emph{save} commands, all game element definitions are included in the game save. Because of this, these commands aren't very useful for testing.

Walkthroughs, on the other hand, can save a sequence of commands needed to arrive at a certain point in a game. This makes them useful for functional testing. Walkthrough files are simply a YAML list of commands.

To create a walkthrough, simply start you game and play it until the point at which you'd like your walkthrough to end. Entering the command \emph{save walkthrough} will then allow you to save the walkthrough. When you wish to use a walkthrough, start or restart Fashion Quest and enter the command \emph{load walkthrough}.

An example walkthrough is provides for the ``Pirate Adventure Knockoff'' demonstration game. It lives in the \emph{pirate\_adventure} directory and is named \emph{complete\_walkthrough}. It cycles through all the commands needed to win the game. Once the walkthrough has loaded, enter the command \emph{score} and the win will be confirmed.


\subsection{Transcripts}
\label{fine_tuning:transcripts}
While walkthroughs are good for confirming nothing is broken, transcripts provide a way to confirm no output in a game has changed.

The built-in command \emph{save transcript} will save the game output to a file. You can then make changes to your game, enter the commands needed to arrive at the point in the game where you originally saved the transcript, and use the built-in command \emph{compare transcript} to compare the game output to the original transcript.



\renewcommand{\indexname}{Index}
\printindex
\end{document}
